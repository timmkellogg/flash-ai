<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Kanji Quest</title>
<style>
  :root {
    --bg: #1a1d29;
    --panel: #232636;
    --accent: #6cf;
    --accent2: #ffcc66;
    --text: #e9ecf1;
    --hp: #69d06c;
    --hp-opp: #ff6666;
    --gap: 12px;
  }
  * { box-sizing: border-box }
  html, body { height: 100% }
  body {
    margin: 0;
    background: var(--bg);
    color: var(--text);
    font: clamp(14px, 2.2vw, 16px)/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    display: grid;
    place-items: center;
    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)
  }

  .game {
    width: min(100vw, 1000px);
    display: grid;
    grid-template-columns: 640fr 340fr;
    gap: var(--gap);
    padding: var(--gap);
  }

  .screen, .panel {
    background: var(--panel);
    border: 2px solid #0008;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 6px 18px #0008, inset 0 0 0 2px #0003
  }

  /* Overworld */
  .screen {
    position: relative;
    aspect-ratio: 4/3;
    touch-action: none; /* stop double-tap zoom/pan while using controls */
  }
  .map {
    position: absolute;
    inset: 0;
    display: grid;
    grid-template-columns: repeat(20, 1fr);
    grid-template-rows: repeat(15, 1fr);
  }
  .tile {
    border-right: 1px solid #0002;
    border-bottom: 1px solid #0002;
  }
  .t-grass { background: linear-gradient(135deg, #2f7b3b, #3ea34b) }
  .t-path  { background: linear-gradient(135deg, #7b6a4b, #9b865d) }
  .t-water { background: linear-gradient(135deg, #2d4f8a, #3f6fb7) }
  .t-start { background: linear-gradient(135deg, #46724e, #6aa86e) }

  .player {
    position: absolute;
    width: calc(100% / 20);
    height: calc(100% / 15);
    transition: transform 120ms linear;
    display: grid;
    place-items: center;
    font-weight: 900;
    text-shadow: 0 2px 0 #0008;
    filter: drop-shadow(0 4px 4px #0008);
    pointer-events: none;
  }
  .sprite {
    width: 70%;
    height: 70%;
    border-radius: 4px;
    background: radial-gradient(circle at 50% 40%, #fffa, #fff0),
                linear-gradient(#eee, #bbb);
    border: 2px solid #0006;
  }

  /* Battle UI */
  .battle {
    position: absolute;
    inset: 0;
    background: linear-gradient(180deg, #111a, #000c), radial-gradient(1200px 600px at 50% 80%, #2b3350, #0b0d14);
    display: none;
    padding: 10px;
    gap: 10px;
  }
  .battle.active { display: grid; grid-template-rows: 1fr auto }

  .battle-top {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }
  .card {
    background: #ffffff10;
    border: 2px solid #0008;
    border-radius: 10px;
    padding: 10px;
  }
  .name { font-weight: 800; letter-spacing: .5px }
  .hpbar {
    height: 10px;
    background: #0006;
    border-radius: 6px;
    overflow: hidden;
    margin-top: 6px;
  }
  .hpbar > div { height: 100%; background: var(--hp) }
  .hpbar.enemy > div { background: var(--hp-opp) }

  .kanji {
    font-size: clamp(60px, 12vw, 96px);
    text-align: center;
    line-height: 1;
    padding: 6px 0 0;
  }

  .battle-actions {
    margin-top: 6px;
    display: grid;
    grid-template-columns: 1fr;
    gap: 8px;
  }
  .choices { display: grid; grid-template-columns: 1fr 1fr; gap: 8px }
  button {
    background: #111a;
    color: var(--text);
    border: 2px solid #000;
    border-radius: 12px;
    padding: clamp(10px, 2.4vw, 14px) 12px;
    font: inherit;
    cursor: pointer;
    box-shadow: 0 2px 0 #0008;
    -webkit-tap-highlight-color: transparent;
  }
  button:hover { background: #182137 }
  button.primary { background: #20355c; border-color: #000; box-shadow: 0 2px 0 #0008, inset 0 0 0 2px #ffffff10 }
  .sys {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    background: #0006;
    border-radius: 8px;
    padding: 8px 10px;
    min-height: 48px;
    display: grid;
    align-content: center;
  }

  /* Sidebar */
  .panel { padding: 12px }
  .row { display: flex; align-items: center; justify-content: space-between; gap: 8px }
  .xp { height: 8px; background: #0006; border-radius: 6px; overflow: hidden; min-width: 120px }
  .xp > div { height: 100%; background: var(--accent2) }
  .stat { opacity: .9 }
  .kbd { padding: 2px 6px; border: 1px solid #ffffff20; border-bottom-width: 2px; border-radius: 6px; background: #0003; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace }

  .muted { opacity: .8; font-size: 14px }
  .footer { margin-top: 8px; font-size: 13px; opacity: .8 }

  /* On-screen controls */
  .controls {
    position: absolute;
    inset: auto 0 0 0;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    padding: 8px;
    pointer-events: none; /* let buttons decide */
  }
  .dpad, .act {
    display: grid;
    pointer-events: auto;
  }
  .dpad {
    grid-template-areas:
      ".    up    ."
      "left mid right"
      ".   down   .";
    gap: 8px;
    justify-self: start;
    width: min(42vw, 240px);
    touch-action: manipulation;
  }
  .dpad button { padding: 12px 0 }
  .btn-up   { grid-area: up }
  .btn-down { grid-area: down }
  .btn-left { grid-area: left }
  .btn-right{ grid-area: right }
  .btn-mid  { grid-area: mid; visibility: hidden }
  .act {
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    justify-self: end;
    width: min(42vw, 260px);
  }
  .controls button { font-size: clamp(14px, 3.5vw, 16px) }

  /* Layout for small screens */
  @media (max-width: 900px) {
    .game {
      grid-template-columns: 1fr;
    }
    .panel {
      order: 2;
    }
    .screen {
      order: 1;
      width: 100%;
    }
    .battle-top {
      grid-template-columns: 1fr;
    }
  }
</style>
</head>
<body>
<div class="game">
  <div class="screen" id="screen">
    <div id="map" class="map"></div>
    <div id="player" class="player"><div class="sprite"></div></div>

    <!-- Battle overlay -->
    <div id="battle" class="battle" aria-live="polite">
      <div class="battle-top">
        <div class="card">
          <div class="name">You (Lv <span id="pLevel"></span>)</div>
          <div class="hpbar"><div id="pHPBar" style="width:100%"></div></div>
          <div class="stat">HP: <span id="pHPText"></span></div>
        </div>
        <div class="card">
          <div class="row">
            <div class="name">Wild Kanji</div>
            <div>Lv <span id="eLevel"></span></div>
          </div>
          <div class="hpbar enemy"><div id="eHPBar" style="width:100%"></div></div>
          <div class="kanji" id="kanjiChar">日</div>
          <div class="row muted"><div>Reading: <b id="readingHint">—</b></div><div>Type: <span id="kanjiTag">N5</span></div></div>
        </div>
      </div>

      <div class="card battle-actions">
        <div class="sys" id="sysMsg">A wild kanji appeared!</div>
        <div class="choices" id="choices"></div>
        <div class="row">
          <button id="hintBtn">Hint</button>
          <button id="runBtn">Run</button>
        </div>
      </div>
    </div>

    <!-- On-screen controls (mobile + desktop touch) -->
    <div class="controls" id="controls">
      <div class="dpad">
        <button class="btn-up"   data-dir="up">▲</button>
        <button class="btn-left" data-dir="left">◀</button>
        <button class="btn-mid" disabled>•</button>
        <button class="btn-right" data-dir="right">▶</button>
        <button class="btn-down" data-dir="down">▼</button>
      </div>
      <div class="act">
        <button id="hintBtn2">Hint</button>
        <button id="runBtn2">Run</button>
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="row">
      <div><b>Kanji Quest</b></div>
      <div class="muted">v0.2 (mobile)</div>
    </div>
    <hr style="border:none;border-top:1px solid #0004;margin:10px 0">
    <div class="row"><div>Level</div><div id="level">1</div></div>
    <div class="row"><div>XP</div><div class="xp"><div id="xpBar" style="width:0%"></div></div></div>
    <div class="row"><div>HP</div><div id="hp" class="stat">20 / 20</div></div>
    <div class="row"><div>Streak</div><div id="streak" class="stat">0</div></div>
    <div class="row"><div>Tiles Explored</div><div id="steps" class="stat">0</div></div>

    <hr style="border:none;border-top:1px solid #0004;margin:10px 0">
    <div><b>Controls</b></div>
    <div class="muted">
      Move with arrow keys or on‑screen D‑pad • Choose answers by tapping • Hint/Run buttons duplicated near the D‑pad
    </div>

    <div class="footer">
      Progress auto-saves in your browser. Beat kanji to earn XP and level up to face harder ones.
    </div>
    <div style="margin-top:8px" class="row">
      <button id="saveBtn">Save</button>
      <button id="resetBtn">Reset</button>
    </div>
  </div>
</div>

<script>
  // --- Minimal Kanji pool (N5 → N4) ---
  const KANJI = [
    {c:'日', m:['sun','day'], on:['ニチ','ジツ'], kun:['ひ','-び','-か'], tag:1},
    {c:'月', m:['moon','month'], on:['ゲツ','ガツ'], kun:['つき'], tag:1},
    {c:'水', m:['water'], on:['スイ'], kun:['みず'], tag:1},
    {c:'火', m:['fire'], on:['カ'], kun:['ひ'], tag:1},
    {c:'木', m:['tree','wood'], on:['ボク','モク'], kun:['き','こ'], tag:1},
    {c:'金', m:['gold','money'], on:['キン','コン'], kun:['かね'], tag:1},
    {c:'土', m:['earth','soil'], on:['ド','ト'], kun:['つち'], tag:1},
    {c:'本', m:['book','origin'], on:['ホン'], kun:['もと'], tag:1},
    {c:'人', m:['person'], on:['ジン','ニン'], kun:['ひと'], tag:1},
    {c:'大', m:['big'], on:['ダイ','タイ'], kun:['おお-'], tag:1},
    {c:'上', m:['up','above'], on:['ジョウ'], kun:['うえ','あ-がる'], tag:1},
    {c:'下', m:['down','below'], on:['カ','ゲ'], kun:['した','さ-がる'], tag:1},
    {c:'右', m:['right'], on:['ウ','ユウ'], kun:['みぎ'], tag:1},
    {c:'左', m:['left'], on:['サ'], kun:['ひだり'], tag:1},
    {c:'中', m:['middle','inside'], on:['チュウ'], kun:['なか'], tag:1},
    {c:'働', m:['work','labor'], on:['ドウ'], kun:['はたら-く'], tag:2},
    {c:'信', m:['trust','faith'], on:['シン'], kun:[], tag:2},
    {c:'習', m:['learn'], on:['シュウ'], kun:['なら-う'], tag:2},
    {c:'便', m:['convenience','mail'], on:['ベン','ビン'], kun:[], tag:2},
    {c:'旅', m:['travel'], on:['リョ'], kun:['たび'], tag:2},
    {c:'軽', m:['light (weight)'], on:['ケイ'], kun:['かる-い'], tag:2},
  ]

  // --- Map / DOM refs ---
  const W = 20, H = 15
  const mapEl = document.getElementById('map')
  const playerEl = document.getElementById('player')
  const battleEl = document.getElementById('battle')
  const sysMsg = document.getElementById('sysMsg')
  const choicesEl = document.getElementById('choices')
  const controlsEl = document.getElementById('controls')

  let map = []
  function genMap() {
    map = []
    for (let y=0; y<H; y++) {
      let row = []
      for (let x=0; x<W; x++) {
        let t = Math.random()
        let tile = 't-grass'
        if (t < 0.08) tile = 't-water'
        else if (t < 0.20) tile = 't-path'
        row.push(tile)
      }
      map.push(row)
    }
    map[H-2][1] = 't-start'
  }

  function drawMap() {
    mapEl.innerHTML = ''
    for (let y=0; y<H; y++) {
      for (let x=0; x<W; x++) {
        const d = document.createElement('div')
        d.className = `tile ${map[y][x]}`
        mapEl.appendChild(d)
      }
    }
  }

  // --- Player / Save ---
  let state = {
    x: 1, y: H-2,
    hp: 20, hpMax: 20,
    level: 1, xp: 0, streak: 0, steps: 0
  }
  function save() { localStorage.setItem('kanjiquest', JSON.stringify(state)) }
  function load() {
    const s = localStorage.getItem('kanjiquest')
    if (!s) return
    try { Object.assign(state, JSON.parse(s)) } catch {}
  }

  // --- UI helpers ---
  const levelEl = document.getElementById('level')
  const hpEl = document.getElementById('hp')
  const xpBar = document.getElementById('xpBar')
  const stepsEl = document.getElementById('steps')
  const streakEl = document.getElementById('streak')
  const pHPText = document.getElementById('pHPText')
  const pHPBar = document.getElementById('pHPBar')
  const pLevel = document.getElementById('pLevel')

  function xpForNext(level) { return 20 + (level-1)*15 }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)) }
  function refreshSidebar() {
    levelEl.textContent = state.level
    hpEl.textContent = `${state.hp} / ${state.hpMax}`
    const need = xpForNext(state.level)
    xpBar.style.width = `${Math.max(0, Math.min(100, state.xp / need * 100))}%`
    stepsEl.textContent = state.steps
    streakEl.textContent = state.streak
  }
  function placePlayer() {
    const w = playerEl.getBoundingClientRect().width
    const h = playerEl.getBoundingClientRect().height
    playerEl.style.transform = `translate(${state.x * w}px, ${state.y * h}px)`
  }

  // --- Battle refs ---
  const kanjiChar = document.getElementById('kanjiChar')
  const readingHint = document.getElementById('readingHint')
  const kanjiTag = document.getElementById('kanjiTag')
  const eHPBar = document.getElementById('eHPBar')
  const eLevel = document.getElementById('eLevel')
  const hintBtn = document.getElementById('hintBtn')
  const runBtn = document.getElementById('runBtn')
  const hintBtn2 = document.getElementById('hintBtn2')
  const runBtn2 = document.getElementById('runBtn2')

  let battle = null
  function randomFrom(arr) { return arr[Math.floor(Math.random() * arr.length)] }
  function pickKanjiForLevel(level) {
    const pool = KANJI.filter(k => k.tag <= Math.ceil(level/2)+1)
    return randomFrom(pool)
  }

  function startBattle() {
    const k = pickKanjiForLevel(state.level)
    battle = {
      k,
      enemyHPMax: 10 + (k.tag-1)*6 + Math.floor(state.level/2),
      enemyHP: 10 + (k.tag-1)*6 + Math.floor(state.level/2),
      shownHint: false,
      over: false
    }
    battleEl.classList.add('active')
    controlsEl.style.display = 'none' // hide D-pad during battle
    kanjiChar.textContent = k.c
    readingHint.textContent = '—'
    kanjiTag.textContent = k.tag === 1 ? 'N5' : 'N4'
    eLevel.textContent = Math.max(1, k.tag + Math.floor((state.level-1)/2))
    sys(`A wild ${k.c} appeared! Choose its meaning to attack.`)
    renderBattle()
    renderChoices(k)
  }

  function renderBattle() {
    pLevel.textContent = state.level
    pHPText.textContent = `${state.hp} / ${state.hpMax}`
    pHPBar.style.width = `${state.hp / state.hpMax * 100}%`
    eHPBar.style.width = `${battle.enemyHP / battle.enemyHPMax * 100}%`
  }
  function sys(t) { sysMsg.textContent = t }

  function endBattle(won) {
    battle.over = true
    setTimeout(() => {
      battleEl.classList.remove('active')
      controlsEl.style.display = '' // restore controls
      if (won) {
        const gain = 8 + Math.floor(Math.random()*5) + (battle.k.tag-1)*4
        state.xp += gain
        state.streak += 1
        sys(`You won and gained ${gain} XP!`)
        let leveled = false
        while (state.xp >= xpForNext(state.level)) {
          state.xp -= xpForNext(state.level)
          state.level += 1
          leveled = true
          state.hpMax += 4
          state.hp = state.hpMax
        }
        if (leveled) toast(`You reached Level ${state.level}!`)
      } else {
        state.streak = 0
        sys(`You escaped to safety.`)
      }
      refreshSidebar()
      save()
    }, 300)
  }

  function enemyStrike() {
    const dmg = 4 + Math.floor(Math.random()*3)
    state.hp = clamp(state.hp - dmg, 0, state.hpMax)
    renderBattle()
    if (state.hp <= 0) {
      toast('You fainted! Sent back to start...')
      state.hp = Math.ceil(state.hpMax * 0.6)
      state.x = 1
      state.y = H-2
      endBattle(false)
    }
  }

  function renderChoices(k) {
    const correct = randomFrom(k.m)
    const wrongPool = Array.from(new Set(KANJI.flatMap(x => x.m))).filter(x => !k.m.includes(x))
    const opts = [correct]
    while (opts.length < 4 && wrongPool.length) {
      const i = Math.floor(Math.random()*wrongPool.length)
      opts.push(wrongPool.splice(i,1)[0])
    }
    while (opts.length < 4) opts.push('—')
    opts.sort(() => Math.random() - 0.5)

    choicesEl.innerHTML = ''
    opts.forEach((label, idx) => {
      const b = document.createElement('button')
      b.className = 'primary'
      b.textContent = `${idx+1}. ${label}`
      b.onclick = () => choose(label, correct)
      choicesEl.appendChild(b)
    })
  }

  function choose(label, correct) {
    if (!battle || battle.over) return
    if (label === correct) {
      const dmg = 6 + state.level + Math.floor(Math.random()*3)
      battle.enemyHP = clamp(battle.enemyHP - dmg, 0, battle.enemyHPMax)
      sys(`Super effective! -${dmg} HP`)
      renderBattle()
      if (battle.enemyHP <= 0) endBattle(true)
      else setTimeout(enemyStrike, 300)
    } else {
      sys(`Not quite… The correct meaning includes “${correct}”.`)
      setTimeout(enemyStrike, 200)
    }
  }

  function revealHint() {
    if (!battle || battle.shownHint) return
    const k = battle.k
    const on = k.on[0] || ''
    const kun = k.kun[0] || ''
    readingHint.textContent = on || kun || 'n/a'
    battle.shownHint = true
    sys('Hint revealed: first reading shown.')
  }
  function tryRun() {
    if (!battle) return
    if (Math.random() < 0.8) endBattle(false)
    else { sys('Couldn’t escape!'); setTimeout(enemyStrike, 250) }
  }
  hintBtn.onclick = revealHint
  runBtn.onclick = tryRun
  hintBtn2.onclick = revealHint
  runBtn2.onclick = tryRun

  // --- Keyboard support (desktop) ---
  let keyHeld = {}
  window.addEventListener('keydown', e => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
      e.preventDefault()
      keyHeld[e.key] = true
      moveTick()
      startMoveLoop()
    } else if (battleEl.classList.contains('active') && ['1','2','3','4'].includes(e.key)) {
      const i = Number(e.key) - 1
      const btn = choicesEl.children[i]
      if (btn) btn.click()
    }
  })
  window.addEventListener('keyup', e => {
    keyHeld[e.key] = false
    if (!anyDirectionHeld()) stopMoveLoop()
  })

  // --- Touch / D-pad support ---
  const dirMap = { up:[0,-1], down:[0,1], left:[-1,0], right:[1,0] }
  let touchHeld = { up:false, down:false, left:false, right:false }
  document.querySelectorAll('[data-dir]').forEach(btn => {
    const dir = btn.getAttribute('data-dir')
    const start = e => {
      e.preventDefault()
      touchHeld[dir] = true
      moveTick()
      startMoveLoop()
    }
    const end = e => {
      e.preventDefault()
      touchHeld[dir] = false
      if (!anyDirectionHeld()) stopMoveLoop()
    }
    btn.addEventListener('touchstart', start, { passive:false })
    btn.addEventListener('touchend', end)
    btn.addEventListener('touchcancel', end)
    btn.addEventListener('mousedown', start)
    btn.addEventListener('mouseup', end)
    btn.addEventListener('mouseleave', end)
  })

  function anyDirectionHeld() {
    return keyHeld.ArrowUp || keyHeld.ArrowDown || keyHeld.ArrowLeft || keyHeld.ArrowRight
      || touchHeld.up || touchHeld.down || touchHeld.left || touchHeld.right
  }

  // Continuous move loop (works for key & touch)
  let moveTimer = null
  function startMoveLoop() {
    if (moveTimer) return
    const step = () => {
      if (!anyDirectionHeld() || battleEl.classList.contains('active')) {
        stopMoveLoop()
        return
      }
      moveTick()
      moveTimer = setTimeout(step, 110)
    }
    moveTimer = setTimeout(step, 110)
  }
  function stopMoveLoop() {
    clearTimeout(moveTimer)
    moveTimer = null
  }

  // Calculate intended direction each tick
  function desiredDelta() {
    let dx = 0, dy = 0
    if (keyHeld.ArrowUp || touchHeld.up) dy = -1
    else if (keyHeld.ArrowDown || touchHeld.down) dy = 1
    else if (keyHeld.ArrowLeft || touchHeld.left) dx = -1
    else if (keyHeld.ArrowRight || touchHeld.right) dx = 1
    return [dx, dy]
  }

  function canWalk(x,y) {
    if (x<0 || y<0 || x>=W || y>=H) return false
    if (map[y][x] === 't-water') return false
    return true
  }

  let moveCooldown = 0
  function moveTick() {
    if (battleEl.classList.contains('active')) return
    const now = performance.now()
    if (now < moveCooldown) return
    const [dx, dy] = desiredDelta()
    if (!dx && !dy) return
    const nx = state.x + dx
    const ny = state.y + dy
    if (canWalk(nx, ny)) {
      state.x = nx
      state.y = ny
      state.steps += 1
      placePlayer()
      refreshSidebar()
      if (map[ny][nx] === 't-grass' && Math.random() < encounterChance()) startBattle()
      moveCooldown = now + 90
    }
  }

  function encounterChance() {
    let base = 0.10
    base += Math.min(0.15, state.level * 0.01)
    return base
  }

  // --- Toaster ---
  let toastTimer = null
  function toast(t) {
    sys(t)
    clearTimeout(toastTimer)
    toastTimer = setTimeout(() => sys(''), 2000)
  }

  // --- Buttons ---
  document.getElementById('saveBtn').onclick = () => { save(); toast('Saved!') }
  document.getElementById('resetBtn').onclick = () => {
    if (!confirm('Reset progress?')) return
    localStorage.removeItem('kanjiquest')
    location.reload()
  }

  // --- Init ---
  genMap()
  drawMap()
  load()
  placePlayer()
  refreshSidebar()
  window.addEventListener('resize', placePlayer)
</script>
</body>
</html>